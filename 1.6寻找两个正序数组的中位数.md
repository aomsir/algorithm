# 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
# 我的解法
# 我的想法：首先查询两个数组的长度判断中位数应该在的位置，然后根据奇数偶数制定不同的计算方法。遍历两个数组，从第一个数组的第一个值开始于后面每一个值进行比较，从小到大排序，到指定位置计算中位数
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    <!-- 合并两个数组 -->
    const merged = []
    let i = 0, j = 0
    
    <!-- 遍历两个数组，按顺序合并 -->
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] < nums2[j]) {
            merged.push(nums1[i])
            i++
        } else {
            merged.push(nums2[j])
            j++
        }
    }
    
    <!-- 将剩余元素添加到合并数组中 -->
    while (i < nums1.length) {
        merged.push(nums1[i])
        i++
    }
    
    while (j < nums2.length) {
        merged.push(nums2[j])
        j++
    }
    
    const totalLength = merged.length
    
    <!-- 计算中位数 -->
    if (totalLength % 2 === 1) {
        <!-- 奇数长度，取中间值 -->
        return merged[Math.floor(totalLength / 2)]
    } else {
        <!-- 偶数长度，取中间两个值的平均值 -->
        const mid1 = merged[totalLength / 2 - 1]
        const mid2 = merged[totalLength / 2]
        return (mid1 + mid2) / 2
    }
};
# 问题：要求时间复杂度为O(log(m+n))，该方法是O(m+n)。用二分查找更好

# 标准答案
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    const m = nums1.length;
    const n = nums2.length;
    const total = m + n;
    
    const findKth = (i, j, k) => {
        if (i >= m) return nums2[j + k - 1];
        if (j >= n) return nums1[i + k - 1];
        if (k === 1) return Math.min(nums1[i], nums2[j]);
        
        const mid = Math.floor(k / 2);
        const part1 = Math.min(mid, m - i);
        const part2 = Math.min(mid, n - j);
        
        if (nums1[i + part1 - 1] < nums2[j + part2 - 1]) {
            return findKth(i + part1, j, k - part1);
        } else {
            return findKth(i, j + part2, k - part2);
        }
    };
    
    if (total % 2 === 1) {
        return findKth(0, 0, Math.floor(total / 2) + 1);
    } else {
        const left = findKth(0, 0, total / 2);
        const right = findKth(0, 0, total / 2 + 1);
        return (left + right) / 2;
    }
};
# 理解，用二分查找的方法来寻找两个有序数组的中位数，实际上是在寻找第k小的数（k为中位数的位置）。具体思路是，我们比较两个数组的第k/2个元素，然后排除较小的那个数组的前k/2个元素，因为第k小的数一定不在那里面。然后我们递归地在剩下的元素中寻找第k - 排除个数小的数。