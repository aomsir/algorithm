# 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""
# 我的解法，与答案中垂直扫描法类似
# 首先检查输入数组是否为空，若是则直接返回空字符串，若不为空，以第一个字符串为案例，同时比较所有字符串在同一位置的字符，一旦发现不匹配的字符立即返回结果若。没有输出""
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if (strs.length === 0)
        return " "
    //以第一个字符串为案例比较
    const firstStr = strs[0]
    //遍历第一个字符串的每个字符
    for (let i = 0; i < firstStr.length; i++) {
        const currentChar = firstStr[i]
        //与其他字符串同一位置字符比较
        for (let j = 1; j < strs.length; j++) {
            // 如果当前字符串长度不足或字符不匹配
            if (i >= strs[j].length || strs[j][i] !== currentChar) {
                return firstStr.substring(0, i)
            }
        }
    }
    return firstStr
};

# 标准答案
# 1. 假设第一个字符串为公共前缀。2. 遍历数组中的每个字符串，用当前公共前缀与当前字符串进行比较，不断缩短公共前缀直到当前字符串以该公共前缀开头。3. 如果公共前缀在比较过程中变为空，则立即返回空字符串" "。4. 最后返回公共前缀。也就是说取第一个字符串作为初始前缀，然后依次与后面的字符串比较，逐步缩短前缀直到找到公共前缀或变为空。
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if (strs.length === 0) return "";
    
    let prefix = strs[0];
    for (let i = 1; i < strs.length; i++) {
        while (strs[i].indexOf(prefix) !== 0) {
            prefix = prefix.substring(0, prefix.length - 1);
            if (prefix === "") return "";
        }
    }
    return prefix;
};