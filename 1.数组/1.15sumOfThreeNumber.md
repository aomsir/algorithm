# 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
# 我的解法
# 先对数组进行排序，然后定第一个为i，利用双指针法，从第二个开始定为left，最右边定为right，依次相加，若遇到相同的数字则跳过，相加等于0则符合要求，输出
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    <!-- 存储结果的数组 -->
    const result = [];
    <!-- 先对数组进行排序 -->
    nums.sort((a, b) => a - b);
    <!-- 遍历数组，固定第一个元素i -->
    for (let i = 0; i < nums.length - 2; i++) {
        <!-- 跳过重复的第一个元素，避免重复的三元组 -->
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }
        <!-- 左指针从i的下一个元素开始 -->
        let left = i + 1;
        <!-- 右指针从数组最右边开始 -->
        let right = nums.length - 1;
        <!-- 当左指针在右指针左边时，继续寻找 -->
        while (left < right) {
            <!-- 计算三数之和 -->
            const sum = nums[i] + nums[left] + nums[right];
            if (sum === 0) {
                <!-- 找到符合条件的三元组，添加到结果中 -->
                result.push([nums[i], nums[left], nums[right]]);
                <!-- 跳过重复的左元素 -->
                while (left < right && nums[left] === nums[left + 1]) {
                    left++;
                }
                <!-- 跳过重复的右元素 -->
                while (left < right && nums[right] === nums[right - 1]) {
                    right--;
                }
                <!-- 移动指针继续寻找下一组可能的组合 -->
                left++;
                right--;
            } else if (sum < 0) {
                <!-- 和小于0，需要增大总和，移动左指针向右 -->
                left++;
            } else {
                <!-- 和大于0，需要减小总和，移动右指针向左 -->
                right--;
            }
        }
    }
    return result;
};
    
# 标准答案
<!-- 1.排序数组：先对数组进行排序，这有助于我们使用双指针技术，同时也方便处理重复元素。
2.固定第一个元素：通过 for 循环遍历数组，每次固定一个元素作为三元组的第一个元素（nums [i]）。
3.双指针寻找另外两个元素：
左指针 left 从 i+1 开始，右指针 right 从数组末尾开始
计算三个元素的和：sum = nums [i] + nums [left] + nums [right]
如果 sum 等于 0，说明找到一个符合条件的三元组
如果 sum 小于 0，需要增大总和，因此移动左指针向右
如果 sum 大于 0，需要减小总和，因此移动右指针向左
4.去重处理：
对第一个元素：如果与前一个元素相同则跳过，避免重复三元组
找到符合条件的三元组后，跳过左右指针的重复元素 -->
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    <!-- 存储结果的数组 -->
    const result = [];
    <!-- 对数组进行排序，这是双指针技术的前提 -->
    nums.sort((a, b) => a - b);
    <!-- 遍历数组，固定第一个元素 -->
    for (let i = 0; i < nums.length - 2; i++) {
        <!-- 跳过重复的第一个元素，避免重复的三元组 -->
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }
        <!-- 左右指针，分别指向第一个元素之后的首尾 -->
        let left = i + 1;
        let right = nums.length - 1;    
        <!-- 双指针寻找满足条件的另外两个元素 -->
        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right];
            if (sum === 0) {
                <!-- 找到符合条件的三元组，添加到结果中 -->
                result.push([nums                    nums[i],
                    nums[left],
                    nums[right]
                ]);
                <!-- 跳过重复的左元素 -->
                while (left < right && nums[left] === nums[left + 1]) {
                    left++;
                }
                <!-- 跳过重复的右元素 -->
                while (left < right && nums[right] === nums[right - 1]) {
                    right--;
                }
                <!-- 移动指针继续寻找 -->
                left++;
                right--;
            } else if (sum < 0) {
                <!-- 和小于0，需要增大总和，移动左指针 -->
                left++;
            } else {
                <!-- 和大于0，需要减小总和，移动右指针 -->
                right--;
            }
        }
    }
    return result;
};
    