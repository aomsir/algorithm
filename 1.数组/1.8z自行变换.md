# 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
# 我的解法
# 创建一个数组rows，长度为numRows，每个元素是一个空字符串，用于存储每行的字符。。按组计算，当行数numRows为3时一组4个，当行数为4时一组6个，当行数为5时一组8等等，可得规律为2*numRows-2，遍历字符得到字符长度除以每组长度，后排序读出
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if (numRows === 1) return s;
    
    const rows = new Array(numRows).fill('');
    const cycle = 2 * numRows - 2;
    
    for (let i = 0; i < s.length; i++) {
        const pos = i % cycle;
        if (pos < numRows) {
            rows[pos] += s[i];
        } else {
            rows[cycle - pos] += s[i];
        }
    }
    
    return rows.join('');
};
# 标准答案
# 标准答案思路和我的思路一致，所以这里查到另外一种解法。如果行数为1，直接返回原字符串。初始化行数组：创建一个数组，每个元素代表Z字形中的一行。模拟Z字形遍历：使用一个变量表示当前行和一个方向标志。遍历字符串中的每个字符，将其添加到当前行。当到达第一行或最后一行时，改变方向。合并行：将所有行的字符串合并成一个字符串作为结果。
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if (numRows === 1) return s;
    
    const rows = new Array(numRows).fill('');
    let currentRow = 0;
    let goingDown = false;
    
    for (let i = 0; i < s.length; i++) {
        rows[currentRow] += s[i];
        
        <!-- 当到达第一行或最后一行时，改变方向 -->
        if (currentRow === 0 || currentRow === numRows - 1) {
            goingDown = !goingDown;
        }
        
        currentRow += goingDown ? 1 : -1;
    }
    
    return rows.join('');
};