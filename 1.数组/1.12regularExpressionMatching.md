# 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
# '.' 任意单个字符；'*' 零个或多个前面的那一个元素
<!-- 正则表达式
是一套由普通字符（如 a、b、123）和元字符（如 .、*、^、$）组成的 “模式模板”，用于定义 “想要匹配的字符串格式”。
例如：
普通字符 abc：仅匹配字符串 "abc"（完全相等）；
含元字符的 a.*c：匹配以 a 开头、以 c 结尾，中间包含 “任意字符（.）任意次（*）” 的字符串（如 "abc"、"a123c"、"a#x c" 等）。 -->

<!-- 解法：
可以使用动态规划的方法来解决，创建一个二维数组dp其中 dp[i][j]表示s的前i个字符与 p的前j个字符是否匹配。
1.处理边界问题：空字符串与空模式匹配，模式中以“*”开头
2.每个字符对 (s[i],p[j])：当两个字符相等或者模式为'.'时，结果取决于前一个字符的匹配情况；当模式字符为*时，两种选（匹配0次/匹配1次或多次）
3.最终结果存储在 dp[s.length][p.length] 中，表示整个字符串是否与整个模式匹配 -->
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    <!-- 创建二维数组dp，dp[i][j]表示s的前i个字符与p的前j个字符是否匹配，初始化为false -->
    const dp = new Array(s.length + 1);
    for (let i = 0; i < dp.length; i++) {
        dp[i] = new Array(p.length + 1).fill(false);
    }
    <!-- 空字符串与空模式匹配，空字符串与空模式是匹配的，所以dp[0][0]设为true -->
    dp[0][0] = true;
    <!-- 处理模式p以*开头的情况（如a*b*可以匹配空字符串，因为*可以表示匹配0次） -->
    for (let j = 1; j <= p.length; j++) {
        if (p[j - 1] === '*') {
            dp[0][j] = dp[0][j - 2];
        }
    }
    <!-- 填充dp数组 -->
    for (let i = 1; i <= s.length; i++) {
        for (let j = 1; j <= p.length; j++) {
            <!-- 情况1：当前字符匹配（相等或模式为.） -->
            if (s[i - 1] === p[j - 1] || p[j - 1] === '.') {
                dp[i][j] = dp[i - 1][j - 1];
            }
            <!-- 情况2：模式当前字符为* -->
            else if (p[j - 1] === '*') {
                <!-- 2.1：不使用*前面的字符（匹配0次） -->
                dp[i][j] = dp[i][j - 2];
                <!-- 2.2：如果*前面的字符与s当前字符匹配，可以考虑使用*（匹配1次或多次） -->
                if (s[i - 1] === p[j - 2] || p[j - 2] === '.') {
                    dp[i][j] = dp[i][j] || dp[i - 1][j];
                }
            }
            <!-- 其他情况不匹配，保持默认的false -->
        }
    }
    <!-- 返回整个字符串s与整个模式p是否匹配 -->
    return dp[s.length][p.length];
};