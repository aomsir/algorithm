# 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 
# 我的解法
# 将整数转化为字符串，设置一个数组一次存储整数包括符号，若字符串长度为偶，对称位置字符相等，若字符串长度为奇，除中位数对称位置字符相等。判断，若相等返回true，若不相等返回false
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    // 将整数转换为字符串
    const str = x.toString();
    const length = str.length;
    
    // 遍历字符串的前半部分，与后半部分对称位置比较
    for (let i = 0; i < Math.floor(length / 2); i++) {
        // 对称位置的索引计算：i与length-1-i
        if (str[i] !== str[length - 1 - i]) {
            return false;
        }
    }
    
    // 所有对称位置都相等，是回文数
    return true;
};
    
# 标准答案
<!-- 1.首先处理两种明显不是回文数的情况：负数和个位数为 0 的非零数
2.然后通过循环反转整数的后半部分
3.当反转的部分大于或等于剩余部分时，说明已经处理了一半的数字
4.最后比较原数剩余部分和反转部分是否相等
如果数字长度是偶数，两部分应该完全相等
如果数字长度是奇数，反转部分会比剩余部分多一位，需要去掉中间位再比较

这种方法只需反转一半数字，比反转整个数字更高效，时间复杂度为 O (log n)，空间复杂度为 O (1)。 -->
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    // 负数不是回文数
    if (x < 0) {
        return false;
    }
    
    // 个位数为0但本身不是0的数不是回文数
    if (x % 10 === 0 && x !== 0) {
        return false;
    }
    
    let reversed = 0;
    let original = x;
    
    // 反转整数的后半部分
    while (original > reversed) {
        // 取出original的最后一位，加到reversed的末尾
        reversed = reversed * 10 + original % 10;
        // 移除original的最后一位
        original = Math.floor(original / 10);
    }
    
    // 当数字长度为奇数时，reversed会比original多一位，需要除以10去掉中间位
    return original === reversed || original === Math.floor(reversed / 10);
};