# 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度
# 我的解法
# 我的想法：给字符串的每个字符编号，且定义一个变量maxLength，值为长度，初始值为0，对于每个字符，如果已经在窗口中，则不断从窗口左侧移除字符，直到窗口中不再包含该字符，然后将当前字符加入窗口右侧。记录窗口的最大长度。
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    <!-- 若字符串为空 -->
    if (s.length === 0)
        return 0
    let maxLength = 0
    let currentSubstring = [];
    <!-- 遍历字符串 -->
    for (let i = 0; i < s.length; i++) {
        const char = s[i]
        <!-- 检查当前字符是否存在于当前子串中 -->
        const charIndex = currentSubstring.indexOf(char)
        if (charIndex !== -1) {
            <!-- 如果字符已存在，移除重复字符及其之前的所有字符 -->
            currentSubstring = currentSubstring.slice(charIndex + 1)
        }
        <!-- 将当前字符添加到子串中 -->
        currentSubstring.push(char)
        <!-- 更新最大长度 -->
        if (currentSubstring.length > maxLength) {
            maxLength = currentSubstring.length;
        }
    }
    return maxLength
};
# 出现问题:1.重复字符串出现后不仅要退出循环，还要删除重复字符串，已改进;2.未考虑到字符串为空的情况，已改进

# 标准答案——利用哈希映射记录字符位置
var lengthOfLongestSubstring = function(s) {
    const charMap = new Map(); 
    <!-- 存储字符及其最新索引 -->
    let left = 0;
    let maxLength = 0;
    
    for (let right = 0; right < s.length; right++) {
        const currentChar = s[right];
        
        <!-- 如果字符已存在且在当前窗口内 -->
        if (charMap.has(currentChar) && charMap.get(currentChar) >= left) {
            <!-- 直接移动左指针到重复字符的下一个位置 -->
            left = charMap.get(currentChar) + 1;
        }
        
        <!-- 更新字符的最新位置 -->
        charMap.set(currentChar, right);
        
        <!-- 计算当前窗口长度 -->
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
};
# 理解：使用两个指针left和right，分别表示当前窗口的左右边界，初始值left=0, right=0。使用一个哈希表（或数组）来存储每个字符最近出现的位置。移动右指针right，遍历字符串：如果当前字符已经在哈希表中，并且其位置大于等于left，则更新left为该字符上次出现位置的下一个位置（因为不能有重复，所以要把窗口左边界移动到重复字符的下一个位置）。更新当前字符在哈希表中的位置为当前右指针的位置。计算当前窗口的长度（right-left+1），并更新最大长度。返回最大长度。
