# 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。说明：你不能倾斜容器。
# 我的解法
# 取决于储水量的因素有两个：height和width,在x轴上，每个数相隔1，可以用使用i++累积width，依次计算第一条(i, 0) 和 (i, height[i])线与其他线的存水量，然后依次计算第二条与其他线的存水量，直到最后两条线。在此期间，首先初始化最大存水量为0，每得到一个存水量就与最大存水量对比，若小于最大存水量则最大存水量不变；若大于最大存水量，则更新最大存水量
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    <!-- 初始化最大存水量为0 -->
    let maxArea = 0;
    const n = height.length;
    <!-- 依次计算每条线与其他线的存水量 -->
    for (let i = 0; i < n; i++) {
        <!-- 对于第i条线，与它后面的所有线计算存水量 -->
        for (let j = i + 1; j < n; j++) {
            <!-- 计算宽度：j - i（因为每个数相隔1） -->
            const width = j - i;
            <!-- 计算高度：两条线中较矮的那条 -->
            const currentHeight = Math.min(height[i], height[j]);
            <!-- 计算当前这对线条形成的存水量 -->
            const currentArea = width * currentHeight;
            <!-- 更新最大存水量 -->
            if (currentArea > maxArea) {
                maxArea = currentArea;
            }
        }
    }
    <!-- 返回最大存水量 -->
    return maxArea;
};
# 问题：当输入数组长度较大（如接近题目上限 10^5）时，该方法会因为计算量过大（约 10^10 次操作）超出时间限制

# 标准答案
<!-- 思路：
1.我们使用两个指针，一个从数组的最左端开始（left），一个从最右端开始（right）
2.计算这两个指针所指垂线形成的容器的蓄水量（宽度 × 高度，高度取两者中的较小值）
3.比较并更新最大蓄水量
4.移动指针：总是移动高度较小的那个指针，因为移动高度较大的指针只会导致容器宽度减小而高度不会增加，从而导致蓄水量减少
5.重复步骤 2-4，直到两个指针相遇 -->
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    <!-- 初始化左右指针，分别指向数组的起始和结束位置 -->
    let left = 0;
    let right = height.length - 1;
    <!-- 存储最大面积，初始值为0 -->
    let maxArea = 0;
    <!-- 当左右指针没有相遇时，继续移动指针 -->
    while (left < right) {
        <!-- 计算当前左右指针所指垂线形成的容器的宽度 -->
        const width = right - left;
        <!-- 容器的高度由较矮的那条垂线决定 -->
        const currentHeight = Math.min(height[left], height[right]);
        <!-- 计算当前容器的面积，并更新最大面积 -->
        const currentArea = width * currentHeight;
        maxArea = Math.max(maxArea, currentArea);
        <!-- 移动指针：总是移动较矮的那条垂线，因为移动较高的垂线只会减小面积 -->
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    <!-- 返回最大面积 -->
    return maxArea;
};